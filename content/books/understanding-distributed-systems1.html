---
title: "Understanding TLS Concepts"
date: "2025-10-27"
description: "Notes on TLS handshake, encryption, authentication, integrity, key derivation, and certificates."
tags: ["TLS", "Security", "Encryption", "Authentication", "Certificates", "KDF"]
slug: "tls-concepts-overview"
published: true
external_url: "https://example.com/clean-code"
cover_url: ""
---

---
title: "Understanding TLS Concepts"
date: "2025-10-27"
description: "Notes on TLS handshake, encryption, authentication, integrity, key derivation, and certificates."
tags: ["TLS", "Security", "Encryption", "Authentication", "Certificates", "KDF"]
slug: "tls-concepts-overview"
---

<h2>Core Security Concepts</h2>
<ul>
    <li><strong>Encryption:</strong> Scrambles or encodes the data.</li>
    <li><strong>Authentication:</strong> Verifies the access must be given to authenticated users only.</li>
    <li><strong>Integrity:</strong> Ensures data is not altered during transmission.</li>
</ul>

<hr>

<h2>Encryption Overview</h2>
<p>Encryption protects data transmitted between a client and server by changing it into random characters.</p>

<h3>Steps Involved (Simplified)</h3>
<ol>
    <li>
        <strong>TLS Handshake:</strong>
        <ul>
            <li>During the TCP 3-way handshake, before client and server do the TLS handshake, both parties decide which encryption to use, which algorithm to use, and how to construct a shared secret.</li>
            <li>Server also sends its certificate so the client can verify if the public key belongs to the server.</li>
        </ul>
    </li>
    <li>
        <strong>Key Pair Generation:</strong>
        <ul>
            <li>Each party generates its own key pair.</li>
            <li>Private key: Not shared.</li>
            <li>Public key: Shared publicly.</li>
        </ul>
    </li>
    <li>
        <strong>Asymmetric Encryption:</strong>
        <ul>
            <li>Client has (CPriv, CPub), Server has (SPriv, SPub).</li>
            <li>Private keys are not exchanged, but public keys are.</li>
            <li>After this, both client and server compute a shared secret.</li>
            <li>Mechanisms like Diffie-Hellman (DH) or Elliptic Curve DH (ECDH) are used.</li>
            <li>Client side: SharedSecret = f(CPriv, SPub).</li>
            <li>Server side: SharedSecret = f(SPriv, CPub).</li>
            <li>Mathematically, f() is designed so both sides compute the exact same shared secret.</li>
            <li>The basic aim is to prevent any 3rd party interference in communication.</li>
            <li><strong>Note:</strong> Asymmetric encryption is complex and requires high CPU usage. It's used in the handshake only; later, symmetric encryption is used for transferring data.</li>
        </ul>
    </li>
    <li>
        <strong>Symmetric Encryption:</strong>
        <ul>
            <li>The SharedSecret is not directly used.</li>
            <li>A Key Derivation Function (KDF), like HKDF or PBKDF2, is used to derive the Symmetric Key from the SharedSecret.</li>
            <li>Symmetric_Key = KDF(SharedSecret, salt, context-info).</li>
            <li>The derived key is a symmetric encryption key. Algorithms like AES-128-GCM or ChaCha20-Poly1305 use this key.</li>
        </ul>
    </li>
    <li>
        <strong>Key Derivation (General Concept):</strong>
        <ul>
            <li>Think of the SharedSecret like a seed.</li>
            <li>We can grow different things (keys) according to our need.</li>
            <li><strong>Encryption Key:</strong> Used to encrypt/decrypt data.</li>
            <li><strong>MAC/Integrity Key:</strong> Used to check if data is not altered. TLS uses HMAC (Hashed Message Authentication Code).</li>
            <li><strong>IV/Nonces:</strong> Randomness for each message. An IV is an Initialization Vector.</li>
        </ul>
    </li>
    <li>
        <strong>Rekeying / Renegotiation:</strong>
        <ul>
            <li>If a single key is used for a very long period, attackers can exploit vulnerabilities by collecting many ciphertexts.</li>
            <li>Solutions today include:
                <ol>
                    <li>Periodically renewing the SharedSecret basis.</li>
                    <li>Performing a full handshake again.</li>
                </ol>
            </li>
        </ul>
    </li>
</ol>

<hr>

<h2>Authentication Process</h2>
<p>Basically, encryption is not the only solution for security. How does a client know that 'yes, this is the server'?. Another problem: how will the client know a verified correct server has shared its public key, not any other fake 3rd party?.</p>

<h3>Solution: Certificates & Certificate Authority (CA)</h3>
<ol>
    <li>Server has a key pair (SPub, SPriv). Server provides its SPub to the client.</li>
    <li>Server attaches a certificate along with its public key.</li>
    <li><strong>Certificate Contents:</strong> Server's name/domain, Public key, Expiry date, Issuer Signature.</li>
    <li>When a client sends a message to the server, the server basically signs the message with its SPriv before sending it to the client.</li>
    <li>Client uses the SPub (obtained from the certificate) to verify the signature. If valid, the client knows it is the same server whose SPriv it is associated with.</li>
    <li>The CA is a trusted 3rd party organization that issues digital certificates.</li>
    <li>A website certificate chain typically has 3 levels:
        <ul>
            <li>1. Service certificate (issued to the website).</li>
            <li>2. Intermediate certificate (CA's certificate).</li>
            <li>3. Root certificate (Top level trusted CA).</li>
        </ul>
    </li>
    <li>The Root CA certificate is self-signed.</li>
    <li><strong>Note:</strong> When browsing the internet (https://), the browser uses the CA to confirm the website is genuine.</li>
</ol>

<h3>Verification Process:</h3>
<ol>
    <li>Client (browser) connects to any resource (website).</li>
    <li>Server sends its certificate chain (Service -> Intermediate -> Root).</li>
    <li>Client (browser/OS) checks its system's trusted store.</li>
    <li>If the root is not in the trusted list, the chain is verified in reverse order (Root CA -> Intermediate CA -> Service Certificate).</li>
    <li>If everything is valid, the browser confirms that the server is authentic.</li>
</ol>

<h3>Common Mistake: Expired Certificates</h3>
<ul>
    <li>If a server's certificate expires, the client won't trust it.</li>
    <li>The connection will fail.</li>
    <li>Automation tools are used to auto-renew before expiry for this purpose.</li>
</ul>

<hr>

<h2>Integrity</h2>
<ul>
    <li>The main goal is that data must be secure and unaltered.</li>
    <li>Only encryption and authentication cannot check this.</li>
    <li>Example: Client sends Amount $1000 to Server. An attacker can't read the data (due to encryption), but they can alter random bits of the data.</li>
    <li>For this purpose, we need an extra step of verification (like HMAC).</li>
</ul>

<hr>

<h2>Special Section on KDF (Key Derivation Function)</h2>
<ul>
    <li>SharedSecret is constructed during the TLS handshake.</li>
    <li>Now, the SharedSecret is passed through a Pseudo-Random Function (PRF) and processed.</li>
    <li>The MasterSecret is derived.</li>
    <li>This MasterSecret is the source for symmetric key generation.</li>
    <li>During TLS 1.0/1.1/1.2, a custom HMAC-based PRF is used.</li>
    <li>But TLS 1.3 onwards, HKDF (HMAC-based Key Derivation Function) is used for deriving the master-secret.</li>
</ul>

<h3>Simplified Process in TLS 1.3</h3>
<ul>
    <li><code>traffic-secret = HKDF-Extract(SharedSecret, ...)</code></li>
    <li><code>key = HKDF-Expand(traffic-secret, "key", ...)</code></li>
    <li><code>iv = HKDF-Expand(traffic-secret, "iv", ...)</code></li>
    <li>In TLS 1.3, the master-secret is not actually used directly; it's a layered secret.</li>
    <li>master-secret is approximately equivalent to the traffic-secret.</li>
</ul>